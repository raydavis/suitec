/**
 * Copyright 2015 UC Berkeley (UCB) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('lodash');
var config = require('config');
var cookie = require('cookie');
var cookieParser = require('cookie-parser');
var Embdr = require('embdr');
var fs = require('fs');
var Joi = require('joi');
var os = require('os');
var path = require('path');
var util = require('util');

var AssetsAPI = require('col-assets');
var CanvasAPI = require('col-canvas');
var CategoriesAPI = require('col-categories');
var Collabosphere = require('col-core');
var CollabosphereConstants = require('col-core/lib/constants');
var CollabosphereUtil = require('col-core/lib/util');
var DB = require('col-core/lib/db');
var log = require('col-core/lib/logger')('col-whiteboards');
var UserConstants = require('col-users/lib/constants');
var UsersAPI = require('col-users');

var WhiteboardUtil = require('./util');

// The interval (in seconds) when thumbnails should be generated
var THUMBNAIL_INTERVAL = 15;

// Keep track of the whiteboards for which a new thumbnail should be generated. The actual thumbnail
// generation happens every THUMBNAIL_INTERVAL seconds
var scheduledThumbnails = {};

/**
 * Get a full whiteboard profile, including the list of members, online members and
 * whiteboard elements.
 *
 * Each member will have an extra `online` property that indicates whether the user is currently
 * editing the whiteboard. The whiteboard elements will be returned in their serialized (JSON) form
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {Number}         id                              The id of the whiteboard
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Whiteboard}     callback.whiteboard             The requested whiteboard
 */
var getWhiteboardProfile = module.exports.getWhiteboardProfile = function(ctx, id, callback) {
  getFullWhiteboard(ctx, id, function(err, whiteboard) {
    if (err) {
      return callback(err);
    }

    // Serialize the whiteboard
    var data = whiteboard.toJSON();

    // Return the elements in a format that can be understood by Fabric.js
    data.whiteboard_elements = _.pluck(whiteboard.whiteboardElements, ['element']);

    // Add the serialized members including an `online` indicator
    data.members = _.map(whiteboard.members, function(member) {
      member = member.toJSON();
      member.online = _.findWhere(whiteboard.onlineUsers, {'user_id': member.id}) ? true : false;
      return member;
    });

    return callback(null, data);
  });
};

/**
 * Get a whiteboard, including the list of members, online members and whiteboard
 * elements
 *
 * The online users, members and whiteboard elements are all original Sequelize instances
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {Number}         id                              The id of the whiteboard
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Whiteboard}     callback.whiteboard             The requested whiteboard
 * @api private
 */
var getFullWhiteboard = function(ctx, id, callback) {
  // Get the base whiteboard
  getBasicWhiteboard(ctx, id, function(err, whiteboard) {
    if (err) {
      return callback(err);
    }

    // Get the members of the whiteboard
    whiteboard.getUsers({'attributes': UserConstants.BASIC_USER_FIELDS}).complete(function(err, members) {
      if (err) {
        log.error({'err': err, 'whiteboard': id}, 'Failed to get the whiteboard members');
        return callback({'code': 500, 'msg': err.message});
      }
      whiteboard.members = members;

      // Get the whiteboard elements
      whiteboard.getWhiteboardElements().complete(function(err, whiteboardElements) {
        if (err) {
          log.error({'err': err, 'whiteboard': id}, 'Failed to get the whiteboard elements');
          return callback({'code': 500, 'msg': err.message});
        }
        whiteboard.whiteboardElements = whiteboardElements;

        // Get the online users in the whiteboard
        getOnlineUsers(id, function(err, onlineUsers) {
          if (err) {
            return callback(err);
          }
          whiteboard.onlineUsers = onlineUsers;

          return callback(null, whiteboard);
        });
      });
    });
  });
};

/**
 * Get a basic whiteboard profile
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {Number}         id                              The id of the whiteboard
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Whiteboard}     callback.whiteboard             The requested whiteboard
 * @api private
 */
var getBasicWhiteboard = function(ctx, id, callback) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'id': Joi.number().required()
  });

  var validationResult = Joi.validate({
    'id': id
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the whiteboard from the DB
  var options = {
    'where': {
      'id': id,
      'course_id': ctx.course.id
    }
  };

  // Verify if the current user has access to the whiteboard. Course administrators
  // have access to all whiteboards in the course
  if (!ctx.user.is_admin) {
    options.include = {
      'model': DB.User,
      'required': true,
      'where': {
        'id': ctx.user.id
      }
    };
  }

  DB.Whiteboard.find(options).complete(function(err, whiteboard) {
    if (err) {
      log.error({'err': err, 'id': id}, 'Failed to get a whiteboard');
      return callback({'code': 500, 'msg': err.message});
    } else if (!whiteboard) {
      log.debug({'err': err, 'id': id}, 'A whiteboard with the specified id could not be found');
      return callback({'code': 404, 'msg': 'A whiteboard with the specified id could not be found'});
    }

    return callback(null, whiteboard);
  });
};

/**
 * Get the whiteboards to which the current user has access in the current course
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {Number}         [limit]                         The maximum number of results to retrieve. Defaults to 10
 * @param  {Number}         [offset]                        The number to start paging from. Defaults to 0
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Object}         callback.whiteboards            The retrieved whiteboards
 * @param  {Number}         callback.whiteboards.total      The total number of whiteboards to which the current user has access in the current course
 * @param  {Whiteboard[]}   callback.whiteboards.results    The paged whiteboard to which the current user has access in the current course
 */
var getWhiteboards = module.exports.getWhiteboards = function(ctx, limit, offset, callback) {
  // Default some parameters
  limit = CollabosphereUtil.getNumberParam(limit, 10, 1, 25);
  offset = CollabosphereUtil.getNumberParam(offset, 0, 0);

  // Parameter validation
  var validationSchema = Joi.object().keys({
    'limit': Joi.number().required(),
    'offset': Joi.number().required()
  });

  var validationResult = Joi.validate({
    'limit': limit,
    'offset': offset
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the whiteboards from the DB
  var options = {
    'where': {
      'course_id': ctx.course.id
    },
    'include': [
      {
        'model': DB.WhiteboardSession,
        'attributes': ['user_id']
      }
    ],
    'order': [['id', 'DESC']],
    'limit': limit,
    'offset': offset
  };

  // If the current user is not a course administrator, only include the whiteboards
  // that have been shared with the current user
  if (!ctx.user.is_admin) {
    options.include.push({
      'model': DB.User,
      'attributes': ['id'],
      'required': true,
      'where': {
        'id': ctx.user.id
      }
    });
  }

  DB.Whiteboard.findAndCountAll(options).complete(function(err, result) {
    if (err) {
      log.error({'err': err, 'course': ctx.course, 'user': ctx.user}, 'Failed to get the whiteboards to which the current user has access in the current course');
      return callback({'code': 500, 'msg': err.message});
    }

    // Add the number of online users for each whiteboard. Note that a single user
    // can have multiple sessions in the same whiteboard. This only counts as a single
    // online user
    result.rows = _.map(result.rows, function(row) {
      row = row.toJSON();
      row.online_count = _.chain(row.whiteboard_sessions).pluck('user_id').uniq().value().length;
      // Remove the session details and current user information from the response
      delete row.whiteboard_sessions;
      delete row.users;
      return row;
    });

    return callback(null, {
      'total': result.count,
      'results': result.rows
    });
  });
};

/**
 * Create a new whiteboard
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {String}         title                           The title of the whiteboard
 * @param  {Number[]}       [members]                       The ids of the users that should be added to the whiteboard as members. The current user will automatically be added as a member
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Whiteboard}     callback.whiteboard             The created whiteboard
 */
var createWhiteboard = module.exports.createWhiteboard = function(ctx, title, members, callback) {
  // Default some parameters
  members = members || [];

  // Add the current user as a member
  members.push(ctx.user.id);

  // Ensure members are only added once
  members = _.uniq(members);

  // Parameter validation
  var validationSchema = Joi.object().keys({
    'title': Joi.string().max(255).required(),
    'members': Joi.array().unique().items(Joi.number()).required()
  });

  var validationResult = Joi.validate({
    'title': title,
    'members': members
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Ensure that all provided members exist
  UsersAPI.getUsers(ctx, members, function(err, users) {
    if (err) {
      return callback(err);
    }

    // Create the whiteboard in the DB
    var whiteboard = {
      'course_id': ctx.course.id,
      'title': title
    };

    DB.Whiteboard.create(whiteboard).complete(function(err, whiteboard) {
      if (err) {
        log.error({'err': err}, 'Failed to create a new whiteboard');
        return callback({'code': 500, 'msg': err.message});
      }

      // Add the members to the whiteboard
      whiteboard.setUsers(members).complete(function(err) {
        if (err) {
          log.error({'err': err}, 'Failed to add members to a new whiteboard');
          return callback({'code': 500, 'msg': err.message});
        }

        // Retrieve the created whiteboard, including the members
        return getWhiteboardProfile(ctx, whiteboard.id, callback);
      });
    });
  });
};

/**
 * Edit a whiteboard
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {Number}         id                              The id of the whiteboard that is being edited
 * @param  {String}         title                           The updated title of the whiteboard
 * @param  {Number[]}       members                         The ids of the users that should be a member of the whiteboard
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Whiteboard}     callback.asset                  The updated whiteboard
 */
var editWhiteboard = module.exports.editWhiteboard = function(ctx, id, title, members, callback) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'id': Joi.number().required(),
    'title': Joi.string().max(255).required(),
    'members': Joi.array().unique().items(Joi.number()).min(1).required()
  });

  var validationResult = Joi.validate({
    'id': id,
    'title': title,
    'members': members
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Ensure that the provided whiteboard exists and the user is allowed to access it
  getBasicWhiteboard(ctx, id, function(err, whiteboard) {
    if (err) {
      return callback(err);
    }

    // Ensure that all provided members exist
    UsersAPI.getUsers(ctx, members, function(err, users) {
      if (err) {
        return callback(err);
      }

      // Update the whiteboard in the DB
      var update = {
        'title': title
      };

      whiteboard.updateAttributes(update).complete(function(err, whiteboard) {
        if (err) {
          log.error({'err': err, 'id': id}, 'Failed to update a whiteboard');
          return callback({'code': 500, 'msg': err.message});
        }

        // Update the members of the whiteboard
        whiteboard.setUsers(members).complete(function(err) {
          if (err) {
            log.error({'err': err}, 'Failed to update the members of a whiteboard');
            return callback({'code': 500, 'msg': err.message});
          }

          // Retrieve the updated whiteboard, including the members and elements
          return getWhiteboardProfile(ctx, whiteboard.id, callback);
        });
      });
    });
  });
};

/**
 * Get the list of online users for a whiteboard
 *
 * @param  {Number}         whiteboardId                    The id of the whiteboard for which to get the online users
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {User[]}         callback.users                  The online users in the whiteboard
 * @api private
 */
var getOnlineUsers = function(whiteboardId, callback) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'whiteboardId': Joi.number().required()
  });

  var validationResult = Joi.validate({
    'whiteboardId': whiteboardId
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the online users from the DB
  var options = {
    'where': {
      'whiteboard_id': whiteboardId
    },
    'attributes': ['user_id'],
    'include': [{
      'model': DB.User,
      'attributes': UserConstants.BASIC_USER_FIELDS
    }]
  };

  DB.WhiteboardSession.findAll(options).complete(function(err, onlineUsers) {
    if (err) {
      log.error({'err': err, 'whiteboard': whiteboardId}, 'Failed to get the online users for a whiteboard');
      return callback({'code': 500, 'msg': err.message});
    }

    // Filter out the duplicate records for those users that have multiple
    // sessions in the same whiteboard
    onlineUsers = _.unique(onlineUsers, function(onlineUser) {
      return onlineUser.user_id;
    });

    return callback(null, onlineUsers);
  });
};

/**
 * Send the list of all online users in a whiteboard to the users in the whiteboard
 *
 * @param  {Number}         whiteboardId                    The id of the whiteboard for which to send an updated list of online users
 * @api private
 */
var notifyOnlineUsers = function(whiteboardId) {
  getOnlineUsers(whiteboardId, function(err, onlineUsers) {
    if (err) {
      return log.error({'err': err}, 'Failed to send the updated list of online users to the users in the whiteboard');
    }

    Collabosphere.appServer.io.sockets.in(whiteboardId).emit('online', onlineUsers);
  });
};

/**
 * Create a new whiteboard session for a specific websocket connection
 *
 * @param  {Socket}         socket                          The socket over which the user is connected
 * @param  {Context}        socket.ctx                      Standard context containing the current user and the current course
 * @param  {Function}       [callback]                      Standard callback function
 * @param  {Object}         [callback.err]                  An error that occurred, if any
 * @api private
 */
var createWhiteboardSession = function(socket, callback) {
  callback = callback || function(err) {};

  var validationSchema = Joi.object().keys({
    'socketId': Joi.string().required(),
    'whiteboardId': Joi.number().required(),
    'userId': Joi.number().required()
  });

  var validationResult = Joi.validate({
    'socketId': socket.id,
    'whiteboardId': socket.whiteboard.id,
    'userId': socket.ctx.user.id
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Create the whiteboard session in the DB
  var whiteboardSession = {
    'socket_id': socket.id,
    'whiteboard_id': socket.whiteboard.id,
    'user_id': socket.ctx.user.id
  };

  DB.WhiteboardSession.upsert(whiteboardSession).complete(function(err) {
    if (err) {
      log.error({'type': err}, 'Failed to create a whiteboard session');
      return callback({'code': 500, 'msg': err.message});
    }

    // Send the updated list of online users to the users in the whiteboard
    notifyOnlineUsers(socket.whiteboard.id);

    return callback();
  });
};

/**
 * Delete a whiteboard session for a specific websocket connection
 *
 * @param  {String}         socketId                        The unique socket id of the whiteboard session that is being deleted
 * @param  {Function}       [callback]                      Standard callback function
 * @param  {Object}         [callback.err]                  An error that occurred, if any
 * @api private
 */
var deleteWhiteboardSession = function(socketId, callback) {
  callback = callback || function() {};

  var validationSchema = Joi.object().keys({
    'socketId': Joi.string().required()
  });

  var validationResult = Joi.validate({
    'socketId': socketId
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the whiteboard session that is being deleted
  var options = {
    'where': {
      'socket_id': socketId
    }
  };

  DB.WhiteboardSession.find(options).complete(function(err, whiteboardSession) {
    if (err) {
      log.error({'err': err, 'socketId': socketId}, 'Failed to retrieve the whiteboard session to delete');
      return callback({'code': 500, 'msg': err.message});
    } else if (!whiteboardSession) {
      log.debug({'err': err, 'socketId': socketId}, 'The whiteboard session that is being deleted could not be found');
      return callback({'code': 404, 'msg': 'The whiteboard session that is being deleted could not be found'});
    }

    // Delete the whiteboard session from the DB
    whiteboardSession.destroy().complete(function(err) {
      if (err) {
        log.error({'err': err, 'socketId': socketId}, 'Failed to delete a whiteboard session');
        return callback({'code': 500, 'msg': err.message});
      }

      // Send the updated list of online users to the users in the whiteboard
      notifyOnlineUsers(whiteboardSession.whiteboard_id);

      return callback();
    });
  });
};

/**
 * Delete all whiteboard sessions. This is necessary when the server restarts, as all
 * websockets will have disconnect without the disconnect logic being executed
 *
 * @param  {Function}       [callback]                      Standard callback function
 * @param  {Object}         [callback.err]                  An error that occurred, if any
 * @api private
 */
var deleteWhiteboardSessions = function(callback) {
  callback = callback || function() {};

  var options = {
    'truncate': true
  };

  DB.WhiteboardSession.destroy(options).complete(function(err) {
    if (err) {
      log.error({'err': err}, 'Failed to delete all whiteboard session');
      return callback({'code': 500, 'msg': err.message});
    }

    return callback();
  });
};

// Delete all whiteboard sessions when the server starts
deleteWhiteboardSessions();

/* WHITEBOARD ELEMENTS */

/**
 * Store a new element that was added to the whiteboard canvas and inform
 * the online users in the whiteboard of the new element
 *
 * @param  {Socket}         socket                          The socket on which the new whiteboard element was sent
 * @param  {Object}         element                         The deserialized whiteboard element that was added
 * @param  {Function}       [callback]                      Standard callback function
 * @param  {Object}         [callback.err]                  An error that occurred, if any
 * @api private
 */
var addWhiteboardElement = function(socket, element, callback) {
  callback = callback || function() {};

  // Store the new element
  upsertWhiteboardElement(socket, element, function(err) {
    if (err) {
      return callback(err);
    }

    // Notify all online users in the whiteboard that a new whiteboard element was added.
    // This will not send a notification over the socket on which the new element was sent
    socket.broadcast.to(socket.whiteboard.id).emit('addElement', element);

    return callback();
  });
};

/**
 * Store an updated whiteboard canvas element and inform
 * the online users in the whiteboard of the element update
 *
 * @param  {Socket}         socket                          The socket on which the whiteboard element update was sent
 * @param  {Object}         element                         The deserialized updated whiteboard element
 * @param  {Function}       [callback]                      Standard callback function
 * @param  {Object}         [callback.err]                  An error that occurred, if any
 * @api private
 */
var updateWhiteboardElement = function(socket, element, callback) {
  callback = callback || function() {};

  // Store the updated element
  upsertWhiteboardElement(socket, element, function(err) {
    if (err) {
      return callback(err);
    }

    // Notify all online users in the whiteboard that a whiteboard element was updated.
    // This will not send a notification over the socket on which the element update was sent
    socket.broadcast.to(socket.whiteboard.id).emit('updateElement', element);

    return callback();
  });
};

/**
 * Create a new whiteboard canvas element. If the whiteboard canvas element
 * already exists, it will be updated
 *
 * @param  {Socket}         socket                          The socket on which the whiteboard element creation update was sent
 * @param  {Object}         element                         The deserialized created or updated whiteboard element
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 */
var upsertWhiteboardElement = function(socket, element, callback) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'whiteboardId': Joi.number().required(),
    'element': Joi.object().required(),
    'uid': Joi.number().required()
  });

  var validationResult = Joi.validate({
    'whiteboardId': socket.whiteboard.id,
    'element': element,
    'uid': element.uid
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Create or update the whiteboard element in the DB
  var whiteboardElement = {
    'whiteboard_id': socket.whiteboard.id,
    'uid': element.uid,
    'element': element
  };

  DB.WhiteboardElement.upsert(whiteboardElement).complete(function(err) {
    if (err) {
      log.error({'type': err}, 'Failed to create or update a whiteboard element');
      return callback({'code': 500, 'msg': err.message});
    }

    // Schedule a new thumbnail for this whiteboard
    scheduleThumbnail(socket.whiteboard.id);

    return callback();
  });
};

/**
 * Delete a whiteboard canvas element that was removed and inform
 * the online users in the whiteboard of the removed element
 *
 * @param  {Socket}         socket                          The socket on which the whiteboard element removal was sent
 * @param  {Object}         element                         The deserialized removed whiteboard element
 * @param  {Function}       [callback]                      Standard callback function
 * @param  {Object}         [callback.err]                  An error that occurred, if any
 * @api private
 */
var deleteWhiteboardElement = function(socket, element, callback) {
  callback = callback || function() {};

  // Parameter validation
  var validationSchema = Joi.object().keys({
    'whiteboardId': Joi.number().required(),
    'element': Joi.object().required(),
    'uid': Joi.number().required()
  });

  var validationResult = Joi.validate({
    'whiteboardId': socket.whiteboard.id,
    'element': element,
    'uid': element.uid
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the whiteboard element that is being deleted
  var options = {
    'where': {
      'whiteboard_id': socket.whiteboard.id,
      'uid': element.uid
    }
  };

  DB.WhiteboardElement.find(options).complete(function(err, whiteboardElement) {
    if (err) {
      log.error({'err': err, 'whiteboardId': socket.whiteboard.id, 'uid': element.uid}, 'Failed to retrieve the whiteboard element to delete');
      return callback({'code': 500, 'msg': err.message});
    } else if (!whiteboardElement) {
      log.debug({'err': err, 'whiteboardId': socket.whiteboard.id, 'uid': element.uid}, 'The whiteboard element that is being deleted could not be found');
      return callback({'code': 404, 'msg': 'The whiteboard element that is being deleted could not be found'});
    }

    whiteboardElement.destroy().complete(function(err) {
      if (err) {
        log.error({'err': err, 'whiteboardId': socket.whiteboard.id, 'uid': element.uid}, 'Failed to delete a whiteboard element');
        return callback({'code': 500, 'msg': err.message});
      }

      // Notify all online users in the whiteboard that a whiteboard element was deleted.
      // This will not send a notification over the socket on which the element update was sent
      socket.broadcast.to(socket.whiteboard.id).emit('deleteElement', element);

      // Schedule a new thumbnail for this whiteboard
      scheduleThumbnail(socket.whiteboard.id);

      return callback();
    });
  });
};

/**
 * Schedule a thumbnail for a whiteboard
 *
 * @param  {Number}   whiteboardId    The id of the whiteboard to schedule a new thumbnail for
 */
var scheduleThumbnail = function(whiteboardId) {
  log.debug({
    'whiteboard': whiteboardId
  }, 'Scheduling thumbnail generation for a whiteboard');
  scheduledThumbnails[whiteboardId] = true;
};

/* WEB SOCKETS */

/**
 * When a user connects over a websocket, add them to the appropriate room based on the
 * whiteboard from which they connected. A record indicating that the user is online in
 * the whiteboard will also be added
 */
Collabosphere.appServer.io.on('connection', function(socket) {
  log.info({'socket': socket.id}, 'Initiating new websocket connection');

  // Extract the API domain, course ID and whiteboard ID from the handshake query
  var apiDomain = socket.handshake.query.api_domain;
  var courseId = socket.handshake.query.course_id;
  var whiteboardId = socket.handshake.query.whiteboard_id;

  // Extract the user id from the session cookie that was sent along in the socket handshake
  var cookieName = apiDomain + '_' + courseId;
  var sessionCookie = cookie.parse(socket.handshake.headers.cookie)[cookieName];
  if (!sessionCookie) {
    log.error({
      'socket': socket.id,
      'whiteboardId': whiteboardId
    }, 'A user tried to connect on a socket without a session cookie');
    return socket.disconnect();
  }
  var userId = cookieParser.signedCookie(sessionCookie, config.get('cookie.secret'));
  if (!userId) {
    log.error({
      'socket': socket.id,
      'whiteboardId': whiteboardId
    }, 'A user tried to connect on a socket with an empty session cookie');
    return socket.disconnect();
  }

  // Verify that the user exists
  UsersAPI.getUser(userId, function(err, user) {
    if (err) {
      log.error({'socket': socket.id, 'userId': userId, 'whiteboardId': whiteboardId}, 'Failed to verify the user for a websocket connection');
      return socket.disconnect();
    }

    // Store a mocked request context on the socket
    socket.ctx = {
      'user': user,
      'course': user.course
    };

    // Verify that the whiteboard exists and the user has access to it
    getBasicWhiteboard(socket.ctx, whiteboardId, function(err, whiteboard) {
      if (err) {
        log.error({'socket': socket.id, 'whiteboardId': whiteboardId}, 'Failed to verify websocket connection');
        return socket.disconnect();
      }

      // Store the whiteboard id on the socket
      socket.whiteboard = whiteboard;

      // Join the room that corresponds to the whiteboard to which the user connected
      socket.join(whiteboardId);

      // Create a whiteboard session for the current socket
      createWhiteboardSession(socket);

      /**
       * Create a new chat message via the websocket
       */
      socket.on('chat', function(body) {
        createChatMessage(socket, body);
      });

      /**
       * A new element was added to the whiteboard canvas
       */
      socket.on('addElement', function(element) {
        log.debug({'socket': socket.id, 'element': element.uid}, 'A new element was added to the whiteboard');
        addWhiteboardElement(socket, element);
      });

      /**
       * A whiteboard canvas element was updated
       */
      socket.on('updateElement', function(element) {
        log.debug({'socket': socket.id, 'element': element.uid}, 'An element on the whiteboard was updated');
        updateWhiteboardElement(socket, element);
      });

      /**
       * A whiteboard canvas element was deleted
       */
      socket.on('deleteElement', function(element) {
        log.debug({'socket': socket.id, 'element': element.uid}, 'An element on the whiteboard was deleted');
        deleteWhiteboardElement(socket, element);
      });

      /**
       * When a user disconnected, they are removed from the room and their online record
       * is deleted as well
       */
      socket.on('disconnect', function() {
        log.debug({'socket': socket.id}, 'Websocket connection was disconnected');

        // Leave the room that corresponds to the whiteboard to which the user was in
        socket.leave(whiteboardId);
        // Remove the whiteboard session for the current socket
        deleteWhiteboardSession(socket.id);
      });
    });
  });
});

/* CHAT */

/**
 * Get a chat message.
 * Note that this is a private method that doesn't do any validation
 *
 * @param  {Number}         id                              The id of the chat message to retrieve
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Comment}        callback.chatMessage            The created chat message
 * @param  {User}           callback.chatMessage.user       The user that created the chat message
 * @api private
 */
var getChatMessage = function(id, callback) {
  var options = {
    'where': {
      'id': id
    },
    'include': [{
      'model': DB.User,
      'attributes': UserConstants.BASIC_USER_FIELDS
    }]
  };
  DB.Chat.find(options).complete(function(err, chatMessage) {
    if (err) {
      log.error({'err': err, 'id': id}, 'Failed to retrieve the chat message');
      return callback({'code': 500, 'msg': err.message});
    }

    return callback(null, chatMessage);
  });
};

/**
 * Create a new chat message on a whiteboard. Note that the access to the whiteboard has already been
 * verified when the websocket connection was initiated
 *
 * @param  {Socket}         socket                          The socket on which the chat message has been sent
 * @param  {Context}        socket.ctx                      Standard context containing the current user and the current course
 * @param  {String}         body                            The body of the chat message
 * @param  {Function}       [callback]                      Standard callback function
 * @param  {Object}         [callback.err]                  An error that occurred, if any
 * @param  {Comment}        [callback.chatMessage]          The created chat message
 * @param  {User}           [callback.chatMessage.user]     The user that created the chat message
 * @api private
 */
var createChatMessage = function(socket, body, callback) {
  callback = callback || function() {};

  // Parameter validation
  var validationSchema = Joi.object().keys({
    'whiteboardId': Joi.number().required(),
    'userId': Joi.number().required(),
    'body': Joi.string().required()
  });

  var validationResult = Joi.validate({
    'whiteboardId': socket.whiteboard.id,
    'userId': socket.ctx.user.id,
    'body': body
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Create the chat message in the database
  var chatMessage = {
    'whiteboard_id': socket.whiteboard.id,
    'user_id': socket.ctx.user.id,
    'body': body
  };

  DB.Chat.create(chatMessage).complete(function(err, chatMessage) {
    if (err) {
      log.error({'err': err}, 'Failed to create a new chat message');
      return callback({'code': 500, 'msg': err.message});
    }

    // Retrieve the created chat message, including the associated user
    getChatMessage(chatMessage.id, function(err, chatMessage) {
      if (err) {
        return callback(err);
      }

      // Send the new chat message to all online users in the whiteboard, including
      // the user that has sent the chat message
      Collabosphere.appServer.io.sockets.in(socket.whiteboard.id).emit('chat', chatMessage);

      return callback(null, chatMessage);
    });
  });
};

/**
 * Get the most recent chat messages for a whiteboard
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {Number}         whiteboardId                    The id of the whiteboard for which to get the most chat messages
 * @param  {Number}         [before]                        The id of the message that happened just after the desired messages. The newest messages will be retrieved when no before id is specified
 * @param  {Number}         [limit]                         The maximum number of results to retrieve. Defaults to 10
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Chat[]}         callback.chatMessages           The most recent chat messages
 */
var getChatMessages = module.exports.getChatMessages = function(ctx, whiteboardId, before, limit, callback) {
  before = CollabosphereUtil.getNumberParam(before);
  limit = CollabosphereUtil.getNumberParam(limit, 10, 1, 25);

  // Parameter validation
  var validationSchema = Joi.object().keys({
    'whiteboardId': Joi.number().required(),
    'before': Joi.number().optional(),
    'limit': Joi.number().required()
  });

  var validationResult = Joi.validate({
    'whiteboardId': whiteboardId,
    'before': before,
    'limit': limit
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the whiteboard for which to retrieve the recent chat messages
  getBasicWhiteboard(ctx, whiteboardId, function(err, whiteboard) {
    if (err) {
      return callback(err);
    }

    // Get the chat messages from the DB
    var options = {
      'where': {
        'whiteboard_id': whiteboardId
      },
      'order': [['created_at', 'DESC']],
      'limit': limit,
      'include': [
        {
          'model': DB.User,
          'attributes': UserConstants.BASIC_USER_FIELDS
        }
      ]
    };

    if (before) {
      options.where.id = {'$lt': before};
    }

    DB.Chat.findAll(options).complete(function(err, chatMessages) {
      if (err) {
        log.error({'err': err, 'whiteboard': whiteboardId}, 'Failed to get the recent chat messages for a whiteboard');
        return callback({'code': 500, 'msg': err.message});
      }

      return callback(null, chatMessages);
    });
  });
};

/**
 * Export a whiteboard to an asset in the asset library
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {Number}         id                              The id of the whiteboard
 * @param  {String}         title                           The title of the exported whiteboard. Defaults to the whiteboard's title
 * @param  {Object}         [opts]                          A set of optional parameters
 * @param  {Number[]}       [opts.categories]               The ids of the categories to which the whiteboard should be associated
 * @param  {String}         [opts.description]              The description of the whiteboard
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Asset}          callback.asset                  The exported asset
 */
var exportWhiteboardToAsset = module.exports.exportWhiteboardToAsset = function(ctx, id, title, opts, callback) {
  // Default the optional values
  opts = opts || {};
  opts.categories = opts.categories || [];

  // Parameter validation
  var validationSchema = Joi.object().keys({
    'id': Joi.number().required(),
    'title': Joi.string().max(255).optional(),
    'opts': Joi.object().keys({
      'categories': Joi.array().unique().items(Joi.number()).optional(),
      'description': Joi.string().allow('').optional()
    })
  });

  var validationResult = Joi.validate({
    'id': id,
    'title': title,
    'opts': opts
  }, validationSchema);
  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the whiteboard including its members and elements
  getFullWhiteboard(ctx, id, function(err, whiteboard) {
    if (err) {
      return callback(err);
    } else if (_.isEmpty(whiteboard.whiteboardElements)) {
      return callback({'code': 400, 'msg': 'An empty board cannot be exported'});
    } else if (!title && !whiteboard.title) {
      return callback({'code': 400, 'msg': '"title" is required'});
    }

    title = title || whiteboard.title;

    // Ensure that all provided categories exist
    CategoriesAPI.getCategoriesById(ctx, opts.categories, function(err, categories) {
      if (err) {
        return callback(err);
      }

      // Get an up-to-date PNG file for the whiteboard that can be used to create a thumbnail for the asset
      getWhiteboardAsPngFile(whiteboard, function(err, imagePath) {
        if (err) {
          return callback(err);
        }

        AssetsAPI.createWhiteboard(ctx, whiteboard, imagePath, title, opts, function(err, asset) {
          // Regardless of the error, remove the temporary PNG file
          fs.unlink(imagePath, function(unlinkError) {
            if (unlinkError) {
              log.error({
                'err': err,
                'whiteboard': id
              }, 'Could not remove a whiteboard\'s exported PNG file');
            }
          });

          return callback(err, asset);
        });
      });
    });
  });
};

/**
 * Export a whiteboard to a PNG image
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {Number}         id                              The id of the whiteboard
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Whiteboard}     callback.whiteboard             The whiteboard that is being exported
 * @param  {Stream}         callback.stream                 The stream that will contain the PNG representation of the whiteboard
 */
var exportWhiteboardToPng = module.exports.exportWhiteboardToPng = function(ctx, id, callback) {
  // Get the whiteboard including its members and elements
  getFullWhiteboard(ctx, id, function(err, whiteboard) {
    if (err) {
      return callback(err);
    } else if (_.isEmpty(whiteboard.whiteboardElements)) {
      return callback({'code': 400, 'msg': 'An empty board cannot be exported'});
    }

    // Get an up-to-date PNG file for the whiteboard
    getWhiteboardAsPngStream(whiteboard, function(err, stream) {
      if (err) {
        return callback(err);
      }

      return callback(err, whiteboard, stream);
    });
  });
};

/**
 * Export the whiteboard to a PNG file on disk
 *
 * @param  {Whiteboard}     whiteboard                      The whiteboard to export
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {String}         callback.imagePath              The path on disk where the image is stored
 * @api private
 */
var getWhiteboardAsPngFile = function(whiteboard, callback) {
  // Get a PNG representation of the whiteboard
  getWhiteboardAsPngStream(whiteboard, function(err, stream) {
    if (err) {
      return callback(err);
    }

    // Flush the PNG to disk
    var filename = util.format('whiteboard-%d-%d.png', whiteboard.id, _.random(100000));
    var imagePath = path.join(os.tmpdir(), filename);
    var writeStream = fs.createWriteStream(imagePath);
    stream.pipe(writeStream);

    // Once the PNG is on disk, we can return to the caller
    writeStream.on('finish', function() {
      return callback(null, imagePath);
    });

    writeStream.on('error', function(err) {
      log.error({
        'err': err,
        'whiteboard': id
      }, 'Could not write the PNG representation of the board to disk');
      return callback({'code': 500, 'msg': 'The board could not be exported'});
    });
  });
};

/**
 * Get the PNG export stream for a whiteboard
 *
 * @param  {Whiteboard}     whiteboard                      The whiteboard to get the PNG data for
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Whiteboard}     callback.stream                 The stream that will contain the PNG data
 * @api private
 */
var getWhiteboardAsPngStream = function(whiteboard, callback) {
  // Fabric.js allows you to position elements with a negative offset (e.g., -100 pixels from the
  // top left corner). This works fine in the whiteboard UI as you can simply re-position the
  // viewport. When exporting to PNG this doesn't make much sense as the element wouldn't be part
  // of the image. We will determine the largest negative offsets and then move all the elements to
  // the right (or bottom) so every element is in the image.
  // The origin of an element (as defined by `originX` and `originY`) can be any permutation of:
  //  - `left`, `center`, `right` and
  //  - `top`, `center`, `bottom`
  // See http://fabricjs.com/test/misc/origin.html for a visual demonstration
  // Additionally, certain elements (such as embedded images) can be re-scaled by adjusting the
  // `scaleX` and `scaleY` properties. When calculating the offsets and canvas size, these needs to
  // be taking into account
  var largestNegativeLeftOffset = 0;
  var largestNegativeTopOffset = 0;
  _.each(whiteboard.whiteboardElements, function(element) {
    var serializedElement = element.element;

    // Calculate the left offset
    var leftOffset = serializedElement.left;
    if (serializedElement.originX === 'center') {
      leftOffset -= (serializedElement.width / 2)  * serializedElement.scaleX;
    } else if (serializedElement.originX === 'right') {
      leftOffset -= serializedElement.width * serializedElement.scaleX;
    }

    // Calculate the top offset
    var topOffset = serializedElement.top;
    if (serializedElement.originY === 'center') {
      topOffset -= (serializedElement.height / 2) * serializedElement.scaleY;
    } else if (serializedElement.originY === 'right') {
      topOffset -= serializedElement.height * serializedElement.scaleY;
    }

    // Keep track of the largest offsets
    largestNegativeLeftOffset = Math.min(largestNegativeLeftOffset, leftOffset);
    largestNegativeTopOffset = Math.min(largestNegativeTopOffset, topOffset);
  });

  // In this second pass we will move each element so there are no more negative offsets. We will
  // also calculate how large the Canvas should be. We do this by looking at the position plus the
  // size of the element
  var width = 0;
  var height = 0;
  _.each(whiteboard.whiteboardElements, function(element) {
    var serializedElement = element.element;

    // Move the element so it's always in the image
    serializedElement.left += (-1 * largestNegativeLeftOffset) + 50;
    serializedElement.top += (-1 * largestNegativeTopOffset) + 50;

    // The width offset
    var widthOffset = serializedElement.width;
    if (serializedElement.originX === 'center') {
      widthOffset = widthOffset / 2;
    } else if (serializedElement.originX === 'right') {
      widthOffset = 0;
    }

    // The height offset
    var heightOffset = serializedElement.height;
    if (serializedElement.originY === 'center') {
      heightOffset = heightOffset / 2;
    } else if (serializedElement.originY === 'bottom') {
      heightOffset = 0;
    }

    // Calculate the outer most pixel this element will take up
    var right = element.element.left + (widthOffset * element.element.scaleX);
    var bottom = element.element.top + (heightOffset * element.element.scaleY);

    // If the element would go beyond the canvas, we make it bigger. We add 50 extra pixels
    // so elements aren't right next to the border
    width = Math.max(width, right + 50);
    height = Math.max(height, bottom + 50);
  });

  // Get a canvas to draw on
  var canvas = WhiteboardUtil.getCanvas(width, height);

  // A variable that will keep track of all the deserialized elements in the whiteboard
  var deserializedElements = [];

  // Convert the board to a PNG file once all the elements have been added
  var render = _.after(whiteboard.whiteboardElements.length, function() {
    // Ensure each element is placed at the right index
    _.each(deserializedElements, function(deserializedElement) {
      deserializedElement.moveTo(deserializedElement.get('index'));
    });

    // Render the entire board
    canvas.renderAll();

    // Convert it to a PNG file and return the stream
    var stream = canvas.createPNGStream();
    return callback(null, stream);
  });

  // Deserialize each whiteboard element and add it to the canvas
  _.each(whiteboard.whiteboardElements, function(whiteboardElement) {
    WhiteboardUtil.deserializeElement(whiteboardElement.element, function(deserializedElement) {
      canvas.add(deserializedElement);

      // Retain a reference to the deserialized elements. This allows for moving each element
      // to the right index once all alements have been added to the canvas
      deserializedElements.push(deserializedElement);

      render();
    });
  });
};

/**
 * Generate the thumbnails for the scheduled whiteboards
 *
 * @api private
 */
var generateScheduledThumbnails = function() {
  var whiteboardIds = _.keys(scheduledThumbnails);
  if (_.isEmpty(whiteboardIds)) {
    return log.debug('There were no scheduled whiteboards to generate thumbnails for');
  }

  _.each(whiteboardIds, function(whiteboardId) {
    log.debug({
      'whiteboard': whiteboardId
    }, 'Generating a thumbnail');

    // Get all the required information to generate an image for the whiteboard
    var options = {
      'where': {
        'id': whiteboardId
      },
      'include': [
        {'model': DB.Course, 'include': [
          {'model': DB.Canvas, 'as': 'canvas'}
        ]},
        {'model': DB.WhiteboardElement, 'as': 'WhiteboardElements'}
      ]
    };
    DB.Whiteboard.findOne(options).complete(function(err, whiteboard) {
      if (err) {
        return log.error({
          'err': err,
          'whiteboard': whiteboardId
        }, 'Could not retrieve a whiteboard when generating a thumbnail for it. The thumbnail will now be out of sync');
      }

      whiteboard.whiteboardElements = whiteboard.WhiteboardElements;

      // Generate a thumbnail for the whiteboard
      generateThumbnail(whiteboard);

      // Take the whiteboard out of the set of scheduled whiteboard for thumbnailing
      delete scheduledThumbnails[whiteboardId];
    });
  });
};

/**
 * Generate a thumbnail for a whiteboard
 *
 * @param  {Whiteboard}     whiteboard    The whiteboard to generate a thumbnail for
 * @api private
 */
var generateThumbnail = function(whiteboard) {
  getWhiteboardAsPngFile(whiteboard, function(err, imagePath) {
    if (err) {
      return log.error({
        'err': err,
        'whiteboard': whiteboard.id
      }, 'Could not generate a PNG image for a whiteboard');
    }

    // Remove the image file when called
    var cleanupFile = function() {
      fs.unlink(imagePath, function(unlinkError) {
        if (unlinkError) {
          log.error({
            'err': err,
            'whiteboard': id
          }, 'Could not remove a whiteboard\'s exported PNG file');
        }
      });
    };

    var embdr = new Embdr(config.get('embdr.apiKey'));
    embdr.process(imagePath, {
      'thumbnails': {
        'sizes': [CollabosphereConstants.THUMBNAIL_SIZE],
        'complete': function(thumbnails) {
          // Persist the thumbnail URL for this whiteboard
          var update = {'thumbnailUrl': thumbnails[CollabosphereConstants.THUMBNAIL_SIZE].url};
          updateWhiteboardPreview(whiteboard, update);

          // Remove the temporary file
          cleanupFile();
        }
      },
      'error': function(err) {
        log.error({
          'err': err,
          'whiteboard': whiteboard.id
        }, 'An error occurred when generating a whiteboard thumbnail');
        cleanupFile();
      }
    });
  });
};

/**
 * Update the preview metadata for a whiteboard
 *
 * @param  {Whiteboard}     whiteboard                      The whiteboard for which the preview metadata is being updated
 * @param  {Object}         opts                            The preview metadata updates that need to be applied
 * @param  {String}         [opts.thumbnailUrl]             The updated thumbnail URL of the whiteboard
 * @api private
 */
var updateWhiteboardPreview = function(whiteboard, opts) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'thumbnailUrl': Joi.string().optional()
  });

  var validationResult = Joi.validate(opts, validationSchema);

  if (validationResult.error) {
    return log.error({
      'err': validationResult.error.details[0].message,
      'update': opts,
      'whiteboard': whiteboard.id
    }, 'Validation error when updating the preview metadata for a whiteboard');
  }

  // Update the whiteboard preview metadata in the DB
  var update = {
    'thumbnail_url': opts.thumbnailUrl
  };
  whiteboard.updateAttributes(update).complete(function(err) {
    if (err) {
      log.error({
        'err': err,
        'update': update,
        'whiteboard': whiteboard.id
      }, 'Failed to update the preview metadata for a whiteboard');
    }

    log.debug({
      'update': update,
      'whiteboard': whiteboard.id
    }, 'Successfully updated the preview metadata for a whiteboard');
  });
};

// Thumbnails can only be generated if the Embdr integration has been enabled
if (config.get('embdr.enabled')) {
  setInterval(generateScheduledThumbnails, THUMBNAIL_INTERVAL * 1000);
}
